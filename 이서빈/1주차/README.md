# Vol. 1 1장 오브젝트와 의존관계 01

## 스프링이란?


### 🌿 **스프링이란?**
---

자바 엔터프라이즈 애플리케이션 개발에 사용되는 애플리케이션 프레임워크


**애플리케이션의 기본 틀 - 스프링 컨테이너**

- 스프링은 스프링 런타임 엔진( == 스프링 컨테이너 == 애플리케이션 컨텍스트)을 제공

**공동 프로그래밍 모델 - 10C/DI,서비스추상화,AOP**

- IoC / DI
    - 오브젝트의 생명주기와 의존관계에 대한 프로그래밍 모델
    - 객체지향 설계 원칙과 디자인 패턴 핵심 원리를 담음
    - 모든기술과 API, 컨테이너도 loC/DI 방식으로 작성됨
- 서비스 추상화
- AOP

## 1. 오브젝트와 의존관계

### 🌿 **스프링이란?**

- 자바(객체지향 프로그래밍) 기반
- 오브젝트 (⭐) - 생성 & 관계 & 사용 & 소멸

## 1.1 초난감 DAO

**🌿 DAO(Data Acess Object)란?**

DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트


### 1.1.1 User

정보 저장할 때는, 자바빈 규약을 따르는 오브젝트 이용하면 편리함

**🥔 자바빈이란?**

- **디폴트 생성자:**
    - 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 함.
    - 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요함
- **프로퍼티:**
    - 자바빈이 노출하는 이름을 가진 속성
    - set : 수정자 메소드(setter) / get : 접근자 메소드(getter)를 이용해 수정 또는 조회


### 1.1.2 UserDao

- **DE 연결:** DE 연결을 위한 Connection을 가져옴
- **SQL 구문 생성:** SQL을 담은 Statement를 만듬
- **SQL 실행:** 만든 Statement를 실행함
- **정보 조회:** SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨줌
- **리소스 정리:** 작업 중 생성된 Connection, Statement, ResultSet 같은 리소스를 작업을 마친 후 반드시 닫아줌
- **예외 처리:** JDBC API가 만들하는 예외를 잡아서 직접 처리하거나, 메소드에 throws를 선언해서 예외가 발생하면 메소드 밖으로 던짐

### 1.1.3 main()을 이용한 DAO 테스트 코드

코드의 기능을 검증하는 방법

- 오브젝트 스스로 자신을 검증
- BUT 문제가 많음

## 1.2 DAO의 분리

### 1.2.1 관심사의 분리

**객체지향**의 세계에서는 **모든 것이 변한다.**

- 변수나 오브젝트 필드의 값이 변하지 X
- **오브젝트에 대한 설계**와 이를 **구현한 코드가 변한다**

**미래의 변화**를 대비

- **객체지향 기술**이 만들어내는 **가상 추상세계 자체**를 효과적으로 구성 & 자유롭고 편리하게 변경, 발전, 확장하는 데 의미가 있음

**변경에 대비하는** 방법 

1. **분리**
    - **관심사의 분리 (Separation of Concerns)**
        - 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 함
        - 관심이 다른 것은 가능한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것
        
        ⇒ **관심사가 같은 것끼리 모으고 다른 것은 분리**해줌으로써 **같은 관심에 효과적으로 집중**할 수 있게 함
        
2. **확장**

### 1.2.2 커넥션 만들기의 추출

**💕 UserDao의 관심사항**

1. **DB와 연결을 위한 커넥션**을 어떻게 가져올까?
2. 사용자 등록을 위해 **DB에 보낼 SQL 문장을 담은 Statement를 만들고 실행**하는 것
3. 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아줘서 **소중한 공유 리소스를 시스템에 돌려주는 것**

**🚫 현재 문제점**

1. DB 연결을 위한 Connection 오브젝트를 가져오는 부분
    - 현재 DB 커넥션을 가져오는 코드는 다른 관심사와 섞여서 같은 메서드(add())에 담겨 있음
    
    ```java
    public void add(User user) throws ClassNotFoundException, SQLDxception {
    		Class.forName("com.mysql.jdbc.Driver");
    		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
    		
    		PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) value(?, ?, ?)");
    		ps.setString(1, user.getId());
    		ps.setString(2, user.getName());
    		ps.setString(3, user.getPassword());
    
    		ps.executeUpdate();
    
    		ps.close();
    		c.close();
    }
    ```
    
    - add() 메소드에 있는 DB 커넷션을 가져오는 코드와 동일한 코드가 get() 메소드에도 중복되어 있음
    
    ```java
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
    ```
    
**✂️ 중복 코드의 메서드 추출**

- 커넥션을 가져오는 중복된 코드를 분리
- 중복된 db 연결 코드를 독립적인 메소드(getConnection())로 만들어둠
- 각 DAO 메소드에서 분리한 getConnection() 메소드를 호출해서 DB 커넥션을 가져오게 만듬

⇒ 한 가지 관심에 대한 변경이 일어날 경우, 그 관심이 집중되는 부분의 코드만 수정하면 됨

⇒ 관심이 다른 코드가 있는 메소드에는 영향을 주지 않음 

⇒ 관심 내용이 독립적으로 존재하므로 수정도 간단해짐


**⚙ 변경사항에 대한 검증: 리팩토링과 테스트**

main 메소드 테스트

- main() 메소드를 여러 번 실행하면 두 번째부터는 무조건 예외 발생
- because 두번째부터는 무조건 예외 발생 (테이블의 기본키인 id 값이 중복되기 때문)
    
    ⇒ main() 메소드 테스트를 다시 실행하기 전에 User 테이블의 사용자 정보를 모두 삭제해줘야 함
    

**💡 메소드 추출이란?**

공통 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것

**🛠 리팩토링이란?**

- **기존의 코드를 외부의 동작 방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술**
- 리팩토링을 하면 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있음
    
    **⇒ 생산성 향상, 코드의 품질은 높아짐, 유지보수 용이, 경고하면서도 유연한 제품 제발 가능**
    
### 1.2.3 DB 커넥션 만들기의 독립

관심사 분리 작업

- 메소드 추출 ⇒ 변화에 좀 더 유연하게 대처하는 코드

Now 변화를 반기는 DAO 만들자!

**🤑 상속을 통한 확장**

- 기존 코드를 한 단계 더 분리!
    - 메소드의 구현 코드를 제거하고 getConnection()을 추상 메소드로 만들자!
    - 추상 메소드라서 메소드 코드는 없지만 메소드 자체는 존재함
        
        ⇒ getConnection()을 호출하는 코드는 그대로 유지
        

- 서브 클래스를 만들자
    - 서브클래스에서 추상 메소드로 선언했던 getConnection() 메소드를 원하는 방식대로 구현할 수 있음
    - getConnection() 메소드를 원하는 방식으로 확장한 후 사용할 수 있음
![Untitled](https://github.com/leeseobin00/spring-study/assets/70849467/d9735e36-9db8-4df1-a166-5016a3b35fbc)

UserDao.java

```java
public abstract class UserDao {
		public void add(User user) throws ClassNotFoundException, SQLException {
				Connection c = getConnection();
				// ...
		}

		public User get(STring id) throws ClassNotFoundException, SQLException {
				Connection c = getConnection();
				// ...
		}

		// 구현 코드는 제거되고 추상 메소드로 바뀌었다.
		// 메소드의 구현은 서브 클래스가 담당한다. 
		public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}
```

SubClass

```coffeescript
public class NUserDao extends UserDao {
		public Connection getConnection() throws ClassNotFoundException, SQLException {
				// N 사 DB Connection 생성코드
		}
}

public class DUserDao extends UserDao {
		public Connection getConnection() throws ClassNotFoundException, SQLException {
				// D 사 DB Connection 생성코드
		}
}
```

관심사항을 분리해 상하위 클래스에 나눠 담도록 만듬

⇒ 상속구조를 통해 성격이 다른 관심사항을 분리한 코드를 만들어내고, 서로 영향을 덜 주도록 함

🛠 **디자인 패턴이란?**

- 소프트웨어 설계 시, 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션
- 디자인 패턴은 주로 객체 지향 설계에 관한 것
- 확장성 추구 방법 1. 클래스 상속 2. 오브젝트 합성
- 각 패턴의 핵심이 담김 목적 or 의도 파악

**🛠 템플릿 메소드 패턴이란?**

- 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법
- 슈퍼 클래스: 변하지 않는 기능
    - 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의함
    - 이를 활용하여 코드의 기본 알고리즘을 담고 있는 템플릿 메소드 생성
- 서브 클래스: 자주 변경되며 확장할 기능
    - 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하여 기능의 일부를 확장함

**🛠 팩토리 메소드 패턴이란?**

- 상속을 통해 기능을 확장하게 하는 패턴
- 슈퍼클래스: 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용함
    - 주로 인터페이스 타입으로 오브젝트를 리턴하므로 서브클래스에서 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼 클래스에서는 알지 못함
- 서브 클래스: 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의함
- 팩토리 메소드: 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드

결론적으로 

- 템플릿 메소드 패턴 / 팩토리 메소드 패턴으로 관심사항이 다른 코드를 분리, 서로 독립적으로 변경 or 확장할 수 있도록 만드는 것은 매우 효과적인 방법

**BUT 단점**

- **상속 사용**
    - **단일 상속**
        - 이미 해당 DAO가 다른 목적을 위해 상속을 하고 있으면 상속이 불가능함
        - 단지 커넥션 객체를 가져오는 방법을 분리하기 위해 상속 구조로 만들어버리면 후에 다른 목적으로 상속을 적용하기 어렵다.
    - **상하위 클래스의 관계**
        - 상속관계는 두 가지 다른 관심사에 대해 긴말한 결합을 허용함
        - 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있음
            
            ⇒ 슈퍼 클래스 내부의 변경이 있을때 모든 서브 클래스를 함께 수정하거나 다시 개발해야할 수 있음
            
    - **다른 DAO 클래스에 적용할 수 없음**
        - DAO 클래스들이 계속 만들어진다면 상속을 통해서 만들어진 구현 코드가 매 DAO 클래스마다 중복되어 나타남


## 1.3 DAO의 확장

- 모든 오브젝트는 변한다
- BUT 오브젝트가 다 동일한 방식으로 변하는 것은 아니다.
- 변화의 성격이 다르다 == 변화의 이유 == 시기 == 주기 등이 다르다
- 상속
    
    ⇒ 추상 클래스를 만들고 이를 상속한 서브 클래스에서 변화가 필요한 부분을 바꿔서 사용 
    
    ⇒ 변화의 성격이 다른 것을 분리해서 서로 영향을 주지 X 
    
    ⇒ 독립적으로 변경
    
- 상속이 아닌 다른 방법을 사용해보자!!

### 1.3.1 클래스의 분리

독립적인 클래스로 만들어보자!

- 새로운 클래스를 만들고 기능을 넣음
- 해당 UserDao는 new 키워드를 사용해서 SimpleConnectionMaker 클래스의 오브젝트를 만들어둠 ⇒ 이를 메소드에서 사용함

**두 개의 독립된 클래스로 분리한 결과**

![Untitled](https://github.com/leeseobin00/spring-study/assets/70849467/3a692d5c-68b7-4ae3-8a01-914dc8d7c182)

- 각 메서드마다 만들 수도 있지만 한번만 오브젝트를 만들어서 저장해두고 계속 사용하는 편이 낫다.
- 상속 X ⇒ abstract X
- 상태를 관리하는 것도 아니니 한 번만 만들어 인스턴스 변수에 저장해두고 메소드에서 사용하게 한다.

### 1.3.2 인터페이스의 도입

💬 **해결책**

- 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리(인터페이스)를 만들자!

🛠 **추상화**

- 어떤 것들의 공통적인 성격을 뽑아내어 따로 분리해내는 작업
- 자바가 추상화를 위해 제공하는 가장 유용한 도구는 인터페이스!!


**인터페이스?**

- 어떤 일을 하겠다는 기능만 정의
- 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춰버림
- 인터페이스를 통해 접근 ⇒ 실제 구현 클래스를 바꿔도 상관 X
- BUT 초기에 한 번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 제거되지 않고 남아 있음
    - DConnection 클래스의 생성자를 호출해서 오브젝트를 생성하는 코드가 여전히 UserDao에 남아 있음.

### 1.3.3 관계설정 책임의 분리

현재 

- UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심이 남아있음
    
    ⇒ 해당 관심사를 담은 코드를 UserDao에서 분리하지 않으면 결코 독립적으로 확장 가능한 클래스가 될 수 X
    

클래스 사이에 관계가 만들어진다는 것

== 한 클래스가 인터페이스 없이 다른 클래스를 직접 사용한다는 것

오브젝트 사이의 관계가 만들어지려면 만들어진 오브젝트가 있어야 함

1. 직접 생성자를 호출해서 직접 오브젝트를 만드는 방법

```jsx
connectionMaker = new DConnectionMaker();
```

1. 외부에서 만들어준 것을 가져오는 방법
    - 외부에서 만든 오브젝트를 전달받으려면 메소드 파라미터나 생성자 파라미터를 이용

**클래스 사이에 불필요한 의존관계를 갖고 있는 구조**

- UserDao의 모든 코드는 ConnectionMaker 인터페이스와만 관계를 갖어야 함
<img width="400" alt="image2" src="https://github.com/leeseobin00/spring-study/assets/70849467/e52da8d9-71e4-4a55-837e-56b05119c5bf">


**관심을 분리하여 클라이언트에게 넘김**

- UserDao 생성자 수정
- → 클라이언트가 미리 만들어둔 ConnectionMaker의 오브젝트가 사용할 ConnectionMaker 오브젝트를 전달해주도록 만듬

```java
public UserDao(ConnectionMaker connectionMaker) {
		this.connectionMaker = connectionMake;
}
```

관계설정 책임이 추가된 UserDao 클라이언트인 main() 메소드

```java
public class UserDaoTest {
		public static void main(String[] args) throws ClassNotFoundException, SQLException {
				ConnectionMaker connectionMaker = new DConnectionMaker();
				// UserDao가 사용할 ConnectionMaker 구현 클래스를 결정하고 오브젝트를 만든다. 

				UserDao dao = new UserDao(connectionMaker);
				// 1. UserDao 생성
				// 2. 사용할 ConnectionMaker 타입의 오브젝트 제공
				// 결국 두 오브젝트 사이의 의존과계 설정 효과
		}
}
```

- UserDao에 있으면 안되는 다른 관심사항, 책임을 클라이언트로 떠넘김
- UserDao의 변경 없이 자신들을 위한 DB 접속 클래스를 만들어서 UserDao가 사용하게 할 수 있음
- 모든 고객이 만족스럽게 DB 연결 기능을 확장해서 사용할 수 있음

**인터페이스를 도입 & 클라이언트의 도움을 얻는 방법의 장점**

1. ConnectionMaker라는 인터페이스를 사용하기만 한다면 다른 DAO 클래스에도 ConnectionMaker의 구현 클래스들을 그대로 적용할 수 있음
2. DAO가 많아져도 ⇒ DB 접속 방법에 대한 관심은 한 군데에 집중됨
3. DB 접속 방법을 변경해야 할 때도 오직 한 곳의 코드만 수정하면 됨

**관계설정 책임을 담당한 클래이언트 UserDaoTest가 추가된 구조**

<img width="421" alt="image" src="https://github.com/leeseobin00/spring-study/assets/70849467/726a108c-c77f-4c0d-a31c-868b99050c54">

### 1.3.4 원칙과 패턴

🛠 **개방 폐쇄 원칙 (OCP, Open-Closed Principle)**

개방 폐괘 원칙을 이용하면 지금까지 해온 리팩토링 작업의 특징과 최종적으로 개선된 설계와 코드의 장점이 무엇인지 효과적으로 설명할 수 있음

---

- **클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.**
- 
- 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙


**🛠 객체지향 설계 원칙 (SOLID)**

- SRP (The Single ResponsibilityPrinciple) : 단일책임원칙
- OCP (The Open Closed Principle) : 개방 폐쇄 원칙
- LSP (The Liskov Substiution Principle): 리스코프 치환 원칙
- ISP (The Intertace Segregation Principle) : 인터페이스 분리 원칙
- DIP (The Dependency Inversion Principle) :의존관계 역전 원칙

**💬 높은 응집도와 낮은 결합도**

개방 폐쇄 원칙은 높은 응집도와 낮은 결합도라는 소프트웨어개발의 고전적인 원리로도 설명이 가능하다.

**높은 응집도**

- 응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것
- 즉 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다

**낮은 결합도**

- 낮은 결합도는 높은 응집도보다 더 민감한 원칙
- 결합도란 '하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도'

**💬 전략 패턴**

- 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리
- 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
- 스프링이란 객체지향적 설계 원칙과 디자인 패턴에 나타난 장점을 개발자들이 활용할 수 있게 해주는 프레임워크


### ⚔ 참고 (GPT 답변) 

1. **템플릿 메소드 패턴과 팩토리 메소드 패턴의 차이**

**템플릿 메소드 패턴**
   - **템플릿 메소드 패턴**은 부모 클래스에서 알고리즘의 구조를 정의하고 일부 단계를 자식 클래스에서 구현하도록 하는 디자인 패턴
   - 이 패턴은 알고리즘의 뼈대를 정의하고, 알고리즘의 일부 단계를 서브클래스에서 구현할 수 있도록 함으로써 코드 중복을 줄이고 공통의 알고리즘 구조를 재사용할 수 있게 함
   - => 즉, 상위 클래스에는 알고리즘의 틀(템플릿)이 정의되어 있고, 그 구현은 하위 클래스에 의해 이루어짐

**팩토리 메소드 패턴**
   - **팩토리 메소드 패턴**은 객체 생성 처리를 서브클래스에게 위임하는 방법으로, 인스턴스화 로직을 사용하는 알고리즘으로부터 분리시키는 패턴
   - 이 패턴은 객체를 생성하는 인터페이스를 정의하지만, 인스턴스를 만들 클래스의 결정은 서브클래스가 담당함
   - => 즉, 팩토리 메소드 패턴은 인스턴스 생성을 위한 인터페이스를 제공하며, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스의 팩토리 메소드가 담당함

   => 기본적인 차이점은 템플릿 메소드 패턴이 알고리즘의 구조를 정의하는 데 초점을 맞추고 있으며, 팩토리 메소드 패턴은 객체 생성의 과정을 서브클래스에 위임하는 데 초점을 맞추고 있다는 점!

3. **팩토리 메소드와 팩토리 메소드 패턴의 팩토리 메소드의 의미 차이**

**팩토리 메소드**
   - **팩토리 메소드**는 객체를 생성하는 메소드
   - 일반적으로 객체 지향 프로그래밍에서 객체 생성을 위해 사용되는 메소드
   - 특정 클래스의 인스턴스를 반환하는 함수나 메소드를 의미
   - 팩토리 메소드는 단순히 객체 생성 로직을 포함하는 메소드를 일컫는 경우가 많음

**팩토리 메소드 패턴의 팩토리 메소드**
   - **팩토리 메소드 패턴의 팩토리 메소드**는 좀 더 구체적인 컨텍스트에서 사용됨
   - 디자인 패턴의 하나로, 객체 생성을 서브클래스가 결정하도록 하는 패턴에서의 핵심 요소
   - 팩토리 메소드 패턴에서의 팩토리 메소드는 인터페이스를 통해 객체를 생성하지만, 실제 어떤 클래스의 인스턴스를 생성할지는 실행 시간에 결정되며, 이 결정은 서브클래스에 의해 이루어짐

   => 즉, 팩토리 메소드는 넓은 의미에서 객체 생성을 위한 메소드를 의미하며, 팩토리 메소드 패턴에서의 팩토리 메소드는 이 패턴의 구조 내에서 특정 객체 생성 책임을 서브클래스에 위임하는 역할을 하는 메소드를 가리킵니다.
   따라서, 후자는 디자인 패턴의 일부로서 더 구체적인 의미와 역할을 가집니다.
   
