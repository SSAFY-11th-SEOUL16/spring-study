# Vol. 1 4장 예외 2

## 4.2 예외 전환

예외 전환의 목적은 두 가지라고 설명했다.

1. 하나는 앞에서 적용해본 것처럼 **런타임 예외로 포장해서 굳이 필요하지 않은 catch/throws를 줄여주는 것**
2. 다른 하나는 **로우레벨의 예외를 좀 더 의미 있고 추상화된 예외로 바꿔서 던져주는 것**

스프링의 JdbcTemplate이 던지는 DataAccessException은 일단 런타임 예외로 SQLException을 포장해주는 역할을 한다.

그래서 대부분 복구가 불가능한 예외인 SQLException에 대해 애플리케이션 레벨에서는 신경 쓰지 않도록 해주는 것이다.

또한 DataAccessException은 SQLException에 담긴 다루기 힘든 상세한 예외정보를 의미 있고 일관성 있는 예외로 전환해서 추상화해주려는 용도로 쓰이기도 한다.

### 4.2.1 JDBC의 한계 😿

**JDBC**

- JDBC는 자바 표준 JDK에서도 가장 많이 사용되는 기능 중의 하나
- DB를 이용해 데이터를 저장하고. 필요한 정보를 조회하는 기능은 대부분의 프로그램에서 필요하기 때문
- JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의
- 각 DB 업체가 JDBC 표준을 따라 만들어진 드라이버를 제공
- **현실적으로 DB를 자유롭게 바꾸어 사용할 수 있는 DB 프로그램을 작성하는 데는 두 가지 걸림돌이 있음**

1. **비표준 SQL**

- JDBC 코드에서 사용하는 SQL
- SQL은 어느 정도 표준화된 언어이고 몇 가지 표준 규약이 있긴 하지만
- 대부분의 DB는 표준을 따르지 않는 비표준 문법과 기능도 제공
- 비표준 특정 DB 전용 문법은 매우 폭넓게 사용
- **하지만 DB의 변경 가능성을 고려해서 유연하게 만들어야 한다면 SQL은 제법 큰 걸림돌**

해결책 🩹

- 호환 가능한 표준 SQL만 사용하는 방법과, DB별로 별도의 DAO를 만들거나 SQL을 외부에 독립시켜서 DB에 따라 변경해 사용하는 방법이 있음 ⇒ 현실성이 없음
- **DAO를 DB별로 만들어 사용하거나 SQL을 외부에서 독립시켜서 바꿔 쓸 수 있게 하는 것**

1. **호환성 없는 SQLException의 DB 에러정보**

- SQLException 때문!
- DB를 사용하다가 발생할 수 있는 예외의 원인은 다양
- DB마다 SQL만 다른 것이 아니라 에러의 종류와 원인도 제각각
- **JDBC API는 이 SQLException 한 가지만 던지도록 설계**
- **결국 호환성 없는 에러 코드와 표준을 잘 따르지 않는 상태 코드를 가진 SQLException만으로 DB에 독립적인 유연한 코드를 작성하는 건 불가능**

### 4.2.2 DB 에러 코드 매핑을 통한 전환 🛠

DB 종류가 바뀌더라도 DAO를 수정하지 않으려면 위의 두 가지 문제를 해결해야 함

SQLException의 비표준 에러 코드와 SQL 상태정보에 대한 해결책

1. **SQL 상태정보에 대한 해결책**
   - DB 에러 코드는 DB에서 직접 제공해주는 것이니 버전이 올라가더라도 어느 정도 일관성이 유지
   - DB별 에러 코드를 참고해서 발생한 예외의 원인이 무엇인지 해석해주는 기능을 만드는 것
2. **SQLException의 비표준 에러 코드**
   - JdbcTemplate을 이용한다면 JDBC에서 발생하는 DB 관련 예외는 거의 신경 쓰지 않아도 됨
   - 하지만 SQLExecption의 서브클래스이므로 여전히 체크 예외라는 점과 그 예외를 세분화하는 기준이 SQL 상태정보를 이용한다는 점에서 여전히 문제점

### 4.2.3 DAO 인터페이스와 DataAccessException 계층구조 🗂

DataAccessException

- JDBC의 SQLException을 전환하는 용도 + JDBC 외의 자바 데이터 액세스 기술에서 발생하는 예외에도 적용
- 의미가 같은 예외라면 데이터 액세스 기술의 종류와 상관없이 일관된 예외가 발생하도록 만들어 줌
- 데이터 액세스 기술에 독립적인 추상화된 예외를 제공하는 것

> **DAO 인터페이스와 구현의 분리**

DAO를 굳이 따로 만들어서 사용하는 이유는 무엇일까?

1. 가장 중요한 이유는 **데이터 액세스 로직**을 담은 코드를 성격이 **다른 코드에서 분리**해놓기 위해서
2. **분리된 DAO**는 **전략 패턴을 적용**해 **구현 방법을 변경해서 사용**할 수 있게 만들기 위해서

DAO는 인터페이스를 사용해 구체적인 클래스 정보와 구현 방법을 감추고 DI를 통해 제공되도록 만드는 것이 바람직

⇒ BUT 메소드 선언에 나타나는 예외정보가 문제

⇒ 사용 불가 because DAO에서 사용하는 데이터 액세스 기술의 API가 예외를 던지기 때문

⇒ 단순한 해결 방법은 모든 예외를 다 받아주는 throws Exception으로 선언하는 것 (무책임한 선언)

⇒ JDBC를 이용한 DAO에서 모든 SQLException을 런타임 예외로 포장

⇒ 완전히 독립적인 인터페이스 선언이 가능

> **데이터 액세스 예외 추상화와 DataAccessException 계층구조**

스프링은 자바의 다양한 데이터 액세스 기술을 사용할 때 발생하는 예외들을 추상화해서 DataAccessException 계층구조 안에 정리해 놓았음

스프링의 DataAccessException은 이런 일부 기술에서만 공통적으로 나타나는 예외를 포함해서 데이터 액세스 기술에서 발생 가능한 대부분의 예외를 계층구조로 분류해 놓았음

<img width="492" alt="Untitled2" src="https://github.com/leeseobin00/spring-study/assets/70849467/d92742f5-e5ed-4dfe-a3f1-bc752ee27c7b">

⇒ 스프링의 데이터 액세스 지원 기술을 이용해 DAO를 만들면 사용 기술에 독립적인 일관성 있는 예외를 던질 수 있음

### 4.2.4 기술에 독립적인 UserDao 만들기

> **인터페이스 적용**

UserDao 인터페이스에는 기존 UserDao 클래스에서 DAO의 기능을 사용하려는 클라이언트들이 필요한 것만 추출해내면 됨.

```java
public interface UserDao {
		void add(User user);
		User get(String id);
		List<User> getAll();
		void deleteAll();
		int getCount();
}
```

⬇

기존 UserDao의 이름 → UserDaoJdbc로 변경하고

UserDao 인터페이스를 구현하도록 implements로 선언

```java
public class UserDaoJdbc implements UserDao {
```

⬇

스프링 설정 파일의 userDao 빈 클래스 이름을 변경

- 빈의 이름은 인터페이스 이름을 따르는 경우가 일반적?
  ㅇㅇ 보통 빈의 이름은 클래스 이름이 아니라, dataSource 빈처럼 클래스의 구현 인터페이스 이름을 따르는 경우가 일반적
  ⇒ 나중에 구현 클래스를 바꿔도 혼란이 없기 때문

> **테스트 보완**

UserDaoTest 테스트 코드에서 UserDao 인스턴스 변수 선언도 UserDaoJdbc로 변경해야할까?

⮕ 아니다!

**@Autowired 사용하여 스프링의 컨텍스트 내에서 정의된 빈 중에서 인스턴스 변수에 주입 가능한 타입의 빈을 찾아줌**

> **DataAccessException 활용 시 주의사항**

DuplicateKeyException - JDBC를 이용하는 경우에만 발생

데이터 엑세스 기술에 따라 다른 예외가 던져짐

JDBC - SQLException에 담긴 DB의 에러 코드를 바로 해석함

JPA, 하이버네이트, JDO 등 - 각 기술이 재정의한 예외들을 가져와 스프링이 최종적으로 DataAccessException으로 변환함

⇒ **DB의 에러 코드와 달리 예외들이 세분화 되어있지 ❌**

## 4.3 정리

- 예외를 잡아서 아무런 조취를 취하지 않거나 **의미 없는 throws 선언을 남발하는 것은 위험**하다.
- **예외는 복구**하거나 예외처리 오브젝트로 의도적으로 전달하거나 **적절한 예외로 전환**해야 한다.
- **좀 더 의미 있는 예외로 변경**하거나, 불필요한 catch/throws를 피하기 위해 **런타임 예외로 포장**하는 두 가지 방법의 예외 전환이 있다.
- **복구할 수 없는 예외는 가능한 한 빨리 런타임 예외로 전환하는 것이 바람직**하다.
- **애플리케이션의 로직을 담기 위한 예외는 체크 예외로** 만든다.
- JDBC의 **SQLException은 대부분 복구할 수 없는 예외이므로 런타임 예외로 포장**해야 한다.
- SQLException의 에러 코드는 DB에 종속되기 때문에 DB에 독립적인 예외로 전환될 필요가 있다.
- 스프링은 **DataAccessException을** 통해 DB에 **독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공**한다.
- **DAO를 데이터 엑세스 기술에서 독립시키려면 인터페이스 도입과 런타임 예외 전환, 기술에 독립적인 추상화된 예외로 전환이 필요**하다.
